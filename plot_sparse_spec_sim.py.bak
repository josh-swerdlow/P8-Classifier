import numpy as np
import os
import glob
import subprocess
from matplotlib.lines import Line2D
from pathlib import Path
import matplotlib.colors as mcolors
import matplotlib as mpl
import matplotlib.pyplot as plt
from shapely.geometry import LineString
from shapely.geometry import Polygon
from descartes import PolygonPatch

def plotSparseSpec(discrim_time,discrim_freq,spec_name,file_dest_dir=None,tracklabels_inrun=np.array([]),tracktimes_inrun=np.array([]),
                   trackfreqs_inrun=np.array([]),evtstarttimes_inrun=np.array([]),evtstartfreqs_inrun=np.array([]),flag_classified=False):
    '''
    Plots (and saves) sparse spectrograms given the discriminated points in time and frequency; it can also overlay tracks and events
    By discriminated points we mean the values of the Katydid signal `discrim:disc-1d`. Usually we would have root or h5 files with this
    and we would process these file through the function processSparseSpec() which calls this function. However this
    function call also be called independently
    Required:
    discrim_time (1d arr): numpy array of discriminated points' times in seconds
    discrim_freq (1d arr): numpy array of discriminated points' frequencies in Hz
    spec_name (str): title for plot
    Optional:
    file_dest_dir (str): path to directory to save plots as png files to; no final forwardslash /
    tracktimes_inrun (2d arr of shape Nx2): numpy array where each row is [start_time,end_time] in seconds; N tracks gives N rows w/ 2 columns
    trackfreqs_inrun (2d arr of shape Nx2): numpy array where each row is [start_freq,end_freq] in Hz; N tracks gives N rows w/ 2 columns
    tracklabels_inrun (1d arr of shape N): numpy array where each entry is either 0, 1 or 2 following the Phase 1 classifier labels
    evtstarttimes_inrun (1d arr): numpy array of events' start times in seconds
    evtstartfreqs_inrun (1d arr): numpy array of events' start frequencies in Hz
    flag_classified (bool): True if plotting tracks which have been classified; used with processSparseSpec2() only
    '''

    handles = [] # for legend
    flag_extra = False # for saving additional spectrogram with tracks or events, or tracks & events and legend
#    min_freq = 1.64e9 # 17 keV
    min_freq = 1.04e9 # 30 keV
#    min_freq = 9.65e8 # 32 keV

    # Plot discriminated points
    fig = plt.figure(figsize=(14,10))
    plt.clf()
    plt.scatter(discrim_time*1e6,(discrim_freq+min_freq)/1e6,s=7,color='k',alpha=0.75,lw=0.2,zorder=2) # discrim points
    plt.xlim(np.min(discrim_time)*1e6,np.max(discrim_time)*1e6)
    plt.ylim(np.min(discrim_freq+min_freq)/1e6,np.max(discrim_freq+min_freq)/1e6)
    plt.xticks(fontsize=12)
    plt.yticks(fontsize=12)
    plt.xlabel(r'Time in Run ($\mu$s)', fontsize=14)
    plt.ylabel('Frequency (MHz)',fontsize=14)
    plt.title(spec_name,fontsize=14)
    if False:
#    if file_dest_dir is not None: # if there is a destination we save it
        file_dest = file_dest_dir + "/" + spec_name + ".png"
        plt.savefig(file_dest,dpi=200)
        print('\t\t{}'.format(spec_name)+'.png')

    if tracktimes_inrun.size and tracklabels_inrun.size: # if there are tracks with classification labels
        spec_name += "+ClassifiedTracks"
        classified_colors = {0:'midnightblue', 1:'palevioletred', 2:'gold'}
        classified_legend = {0:'MainCarrierHigh',1:'MainCarrierLow',2:'Sideband'}
        dilate_dist = 1.25
        cap_style = 1 # cap_style: 1 (round), 2 (flat), 3 (square)
        for idx_track in range(len(tracktimes_inrun)): # there might be more than one track within the acquisition
            track_coords = [(ii_xx,ii_yy) for ii_xx,ii_yy in zip(tracktimes_inrun[idx_track]*1e6,(trackfreqs_inrun[idx_track]+min_freq)/1e6)]
            track_line = LineString(track_coords)
            dilated_track = track_line.buffer(dilate_dist,cap_style=cap_style)
            ax = fig.add_subplot(111)
            polygon_patch = PolygonPatch(dilated_track,alpha=0.5,fc=classified_colors[tracklabels_inrun[idx_track]])
            ax.add_patch(polygon_patch)
            plt.plot(tracktimes_inrun[idx_track]*1e6,(trackfreqs_inrun[idx_track]+min_freq)/1e6,linewidth=2,color=classified_colors[tracklabels_inrun[idx_track]],zorder=1,alpha=0.5)
        plt.title(spec_name,fontsize=14)
        # Legend stuff
        handles.append(Line2D(range(1), range(1), color=classified_colors[0], marker='_',markerfacecolor=classified_colors[0],markersize=10,label=classified_legend[0])) # for legend
        handles.append(Line2D(range(1), range(1), color=classified_colors[1], marker='_',markerfacecolor=classified_colors[1],markersize=10,label=classified_legend[1])) # for legend
        handles.append(Line2D(range(1), range(1), color=classified_colors[2], marker='_',markerfacecolor=classified_colors[2],markersize=10,label=classified_legend[2])) # for legend
        flag_extra = True
    elif tracktimes_inrun.size: # if the track (no classification label) info is present we plot it on top
        spec_name += "+Tracks"
        for idx_track in range(len(tracktimes_inrun)): # there might be more than one track within the acquisition
            plt.plot(tracktimes_inrun[idx_track]*1e6,trackfreqs_inrun[idx_track]/1e6,linewidth=2,color='red',zorder=1)
        plt.title(spec_name,fontsize=14)
        handles.append(Line2D(range(1), range(1), color='red', marker='_',markerfacecolor='red',markersize=10,label='Track')) # for legend
        flag_extra = True
    if evtstarttimes_inrun.size: # if the event info is present we plot it on top
        spec_name += "+Events"
        plt.scatter(evtstarttimes_inrun*1e6,evtstartfreqs_inrun/1e6,marker='o',s=30,edgecolors='k',facecolors='k',zorder=3)
        plt.title(spec_name,fontsize=14)
        handles.append(Line2D(range(1), range(1), color='white', marker='o', markerfacecolor='k',markersize=10,label='Event')) # for legend
        flag_extra = True
#    plt.legend(handles=handles,loc='upper right',fontsize=12) # adding legend
    if ((file_dest_dir is not None) and (flag_extra==True)): # saving the extra spectrogram
        file_dest = file_dest_dir + "/" + spec_name + ".png"
        plt.savefig(file_dest,dpi=300,bbox_inches='tight')
        print('\t\t{}'.format(spec_name)+'.png')
    plt.close()
#    plt.show()
    return

def processSparseSpec(file_loc,file_type='root',file_dest_dir=None,acq_length=0.02,flag_plot_tracks=False,flag_plot_evts=False):
    '''
    Processes a directory where root or h5 (not yet implemented) files sit which have sparse spectrogram data and optionally track and event data
    The files must at least contain discriminated-points data to make plots. Plots can be saved if a destination directory is provided
    By discriminated points we mean the values of the Katydid signal `discrim:disc-1d`

    Required:
    file_loc (str): path to directory where source root or h5 (not yet implemented) files sit; no final forwardslash /
    file_type (str) root or h5 (not yet implemented)

    Optional:
    file_dest_dir (str): path to directory to save plots as png files to; no final forwardslash /
    acq_length (double): acquisition length of data. Defaults to 10 ms which is our usual acquisition length
    flag_plot_tracks (bool): if True then we plot tracks on top of sparse spectrogram
    flag_plot_evts (bool): if True then we plit events on top of sparse spectrogram
    '''

    import ROOT # only need ROOT for this function

    if file_type=="root":
        filelist = glob.glob(file_loc+'/*.root')
    elif file_type=="h5": # not yet implemented
        filelist = glob.glob(file_loc+'/*.h5')
    if not filelist:
        raise Exception("No files found. Aborting")

    for idx_file, ii_file in enumerate(filelist):

        # Getting name for spectrogram from filename
        filename = os.path.split(ii_file)[1] # splits path and keeps file name
        print('Source file: {}'.format(filename))
        filename = os.path.splitext(filename)[0] # removes extension
        # Load file
        file = ROOT.TFile(ii_file)

        try:

            disc = file.Get("discPoints1D") # Discrim points
            NPoints = disc.GetEntries()

        except AttributeError:

            print("\tNo discPoints1D data found. Skipping...")
            continue # next file since without discrim points we don't care for tracks/events

        else: # if there's no exception execute this block

            # LOADING DATA

            freq = np.zeros(NPoints) # allocate space
            time = np.zeros(NPoints)
            # Collect frequencies and times in run
            for ii_point in range(NPoints):
                disc.GetEntry(ii_point)
                freq[ii_point] = disc.fAbscissa
                time[ii_point] = disc.fTimeInRunC

            # Plot tracks?
            if flag_plot_tracks:
                try:
                    proctracks = file.Get("procTracks")
                    NTracks = proctracks.GetEntries()
                except AttributeError:
                    print('\tNo procTracks data found. Skipping...')
                    continue
                else:
                    trackfreqs = np.zeros((NTracks,2)) # To plot lines we need pairs of freqs (start/end) which set the y limits of the line
                    tracktimes = np.zeros((NTracks,2)) # To plot lines we need pairs of times (start/end) which set the x limits of the line
                    for ii_point in range(NTracks): # collect data points
                        proctracks.GetEntry(ii_point)
                        leaf1 = proctracks.FindLeaf("fStartFrequency")
                        leaf2 = proctracks.FindLeaf("fEndFrequency")
                        leaf3 = proctracks.FindLeaf("fStartTimeInRunC")
                        leaf4 = proctracks.FindLeaf("fEndTimeInRunC")
                        trackfreqs[ii_point] = np.array([leaf1.GetValue(),leaf2.GetValue()])
                        tracktimes[ii_point] = np.array([leaf3.GetValue(),leaf4.GetValue()])

            # Plot events?
            if flag_plot_evts:
                try:
                    mtevents = file.Get("multiTrackEvents")
                    NEvents = mtevents.GetEntries()
                except AttributeError:
                    print('\tNo multiTrackEvents data found. Skipping...')
                    continue
                else:
                    evtstartfreqs = np.zeros(NEvents) # allocate space
                    evtstarttimes = np.zeros(NEvents)
                    for ii_point in range(NEvents): # collect data points
                        mtevents.GetEntry(ii_point)
                        leaf1 = mtevents.FindLeaf("fStartFrequency")
                        leaf2 = mtevents.FindLeaf("fStartTimeInRunC")
                        evtstartfreqs[ii_point] = leaf1.GetValue()
                        evtstarttimes[ii_point] = leaf2.GetValue()

            # PLOTTING

            # Data files (h5/root) come from concatenated mat files and thus have huge time gaps
            # We want to get spectrograms from separate acquisitions
            # So we find the time gaps in the data set and save them for later use in the plots
            time_sorted = np.sort(time)
            time_diff = np.diff(time_sorted) # misses the last time limit
            time_upperlim = time_sorted[np.where(time_diff>0.1)[0]]
            time_upperlim = np.append(time_upperlim,time[-1]) # include the last time limit

            if file_dest_dir is not None:
                print('\tSaving files to: {}'.format(file_dest_dir))
            for idx_timelim,ii_timelim in enumerate(time_upperlim): # loop through acquistions in file
                acq_time_start = ii_timelim-acq_length # start time of this acqusition
                spec_name = filename+"_{}".format(idx_timelim)
                kwargs = {'spec_name':spec_name,'file_dest_dir':file_dest_dir} # we'll pas in a kwarg dict for convenience instead of passing in every kwarg argument to plot function
                if flag_plot_tracks: # if so add track information to kwargs
                    acq_cut = (tracktimes[:,0]>=acq_time_start) & (tracktimes[:,1]<=ii_timelim) # cut for tracks within this acquistion only
                    tracktimes_inrun = tracktimes[acq_cut] # track start and end times in this acqusition
                    trackfreqs_inrun = trackfreqs[acq_cut] # track start and end frequencies in this acquisition
                    kwargs['tracktimes_inrun'] = tracktimes_inrun # to send to plotSparseSpec
                    kwargs['trackfreqs_inrun'] = trackfreqs_inrun
                if flag_plot_evts: # if so add event information to kwargs
                    acq_cut = (evtstarttimes>=acq_time_start) & (evtstarttimes<=ii_timelim) # cut for events within this acquistion only
                    evtstarttimes_inrun = evtstarttimes[acq_cut] # event start times in this acqusition
                    evtstartfreqs_inrun = evtstartfreqs[acq_cut] # events start frequencies in this acqusition
                    kwargs['evtstarttimes_inrun'] = evtstarttimes_inrun # to send to plotSparseSpec
                    kwargs['evtstartfreqs_inrun'] = evtstartfreqs_inrun
                acq_cut = (time>=acq_time_start) & (time<=ii_timelim) # time cut for a single acqusition
                plotSparseSpec(time[acq_cut],freq[acq_cut],**kwargs)
                plt.pause(0.05)
    return
